{% extends 'base.html' %}

{% block title %}
GPX Data Detail
{% endblock %}

{% block content %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GPX Data Detail</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.1/chroma.min.js"></script>
    <!-- Include Leaflet.GPX plugin -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.4.0/gpx.min.js"></script>
    <style>
        #map { height: 600px;
               opacity: 1;
               width: auto;
               display: block;
               margin-left: 50px;
               margin-right: 50px;
                 
            }
        button {
            margin: 1px;
            margin-top: 5px;
            border-radius: 10px;
            background-color: rgb(27, 27, 58);
            color: white;
            border-color: white;
            padding: 7px;
            shape-outside: none;
        }
    </style>
</head>
<body>
    <section class="bg-gray-50">
        <div class="mx-auto max-w-screen-xl px-4 py-32 lg:flex lg:h-screen lg:items-center">
        <div class="mx-auto max-w-xl text-center">
        <h1 class="text-3xl font-extrabold sm:text-5xl">
            <strong class="font-extrabold text-indigo-700 sm:block">
            <span id="_text_content">GPX Data Detail - {{ gpx_data.id }}</span>
            </strong>
            </h1>
            <p class="mt-3 text-lg text-gray-500 sm:mt-4">
            <span id="_text_content">This page displays the details of the GPX data with ID {{ gpx_data.id }}.</span>
            </p>
        </div>
        </div>
    </section>
    <div id="map"></div>
    <div>
        <div class="mx-auto max-w-xl text-center">
            <button id="speedButton">Display Speed</button>
            <button id="gradientButton">Display Gradient</button>
            <button id="elevationButton">Display Elevation</button>
            <button id="clearButton">Clear Display</button>
        </div>
    </div>

    <script>
        var map = L.map('map');
        map.getPane('tilePane').style.opacity = 0.4;
        var gpx;
        var speedDisplayed = false;
        var gradientDisplayed = false;
        var elevationDisplayed = false;

        document.getElementById('speedButton').addEventListener('click', function() {
            speedDisplayed = true;
            gradientDisplayed = false;
            elevationDisplayed = false;
            fetchGpx();
        });

        document.getElementById('gradientButton').addEventListener('click', function() {
            speedDisplayed = false;
            gradientDisplayed = true;
            elevationDisplayed = false;
            fetchGpx();
        });

        document.getElementById('elevationButton').addEventListener('click', function() {
            speedDisplayed = false;
            gradientDisplayed = false;
            elevationDisplayed = true;
            fetchGpx();
        });

        document.getElementById('clearButton').addEventListener('click', function() {
            speedDisplayed = false;
            gradientDisplayed = false;
            elevationDisplayed = false;
            fetchGpx();
        });

        async function fetchGpx() {
            try {
                const response = await fetch('/map/gpx_data/{{ gpx_data.id }}/file/');
                gpx = await response.text();

                parseGpxAndSetMap(gpx);

                new L.GPX(gpx, {
                    async: true
                }).on('loaded', function(e) {
                    var gpxLayer = e.target;
                    var track= gpxLayer.getLayers()[0];;
                     
                
                    track.eachLayer(function (segment) {
                    if (speedDisplayed) {
                        displaySpeed(segment);
                    }
                    else if (gradientDisplayed) {
                        displayGradient(segment);
                    }
                    else if (elevationDisplayed) {
                        displayElevation(segment);
                    }
                    
                });
                
                    map.fitBounds(track.getBounds());
                }).addTo(map);
                
            } catch (error) {
                console.log('Error fetching GPX data:', error);
                console.error(error);
            }
        }
        function parseGpxAndSetMap(gpxData) {
            // Parse GPX data and extract coordinates
            var parser = new DOMParser();
            var xmlDoc = parser.parseFromString(gpxData, 'text/xml');
            var trkpts = xmlDoc.getElementsByTagName('trkpt');

            // Initialize variables for minimum and maximum latitude and longitude values
            var minLat, maxLat, minLon, maxLon;

            // Iterate through all trkpt elements to find minimum and maximum latitude and longitude
            for (var i = 0; i < trkpts.length; i++) {
                var lat = parseFloat(trkpts[i].getAttribute('lat'));
                var lon = parseFloat(trkpts[i].getAttribute('lon'));

                // Update minLat, maxLat, minLon, maxLon
                if (i === 0) {
                    minLat = maxLat = lat;
                    minLon = maxLon = lon;
                } else {
                    minLat = Math.min(minLat, lat);
                    maxLat = Math.max(maxLat, lat);
                    minLon = Math.min(minLon, lon);
                    maxLon = Math.max(maxLon, lon);
                }
            }

            // Calculate the center coordinates
            var centerLat = (minLat + maxLat) / 2;
            var centerLon = (minLon + maxLon) / 2;

            // Set the map view to focus on the center coordinates
            map.setView([centerLat, centerLon]);

            // Determine the zoom level to fit the entire route within the map bounds
            var bounds = L.latLngBounds([[minLat, minLon], [maxLat, maxLon]]);
            map.fitBounds(bounds);

            // Add tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            // Add GPX data to the map
            new L.GPX(gpxData, {
                async: true
            }).on('loaded', function(e) {
                var gpxLayer = e.target;
                var track = gpxLayer.getLayers()[0];

                track.eachLayer(function(segment) {
                    // Process each segment of the GPX track, if needed
                });
            }).addTo(map);
        }


        fetchGpx();

        function displaySpeed(segment) {
        // Logic for displaying speed gradient
        var points = segment.getLatLngs();
        for (var i = 0; i < points.length - 1; i++) {
            var speed = calculateSpeed(points[i], points[i + 1]);
            var color = getColorFromSpeed(speed);
            L.polyline([points[i], points[i + 1]], { color: color }).addTo(map);
        }
    }

        function calculateSpeed(point1, point2) {
            var distance = point1.distanceTo(point2); // Distance in meters
            var timeDiff = (point2.meta.time - point1.meta.time) / 1000; // Time difference in seconds
            var speed = distance / timeDiff; // Speed in meters per second
            return speed;
        }

        function getColorFromSpeed(speed) {
            var speedScale = chroma.scale(['blue', 'green', 'yellow', 'orange', 'red']).domain([0, 14]);
            return speedScale(speed).hex();
        }


        function displayGradient(segment) {
        // Logic for displaying gradient
        var points = segment.getLatLngs();
        for (var i = 0; i < points.length - 1; i++) {
            if (i+30 < points.length - 1){
                var gradient = calculateGradient(points[i], points[i + 30]);
            } else {
                var gradient = calculateGradient(points[i], points[i + 1]);
            }
            var color = getColorFromGradient(gradient);
            L.polyline([points[i], points[i + 1]], { color: color }).addTo(map);
            }
        }

        function calculateGradient(point1, point2) {
            var gradient = (point2.meta.ele - point1.meta.ele) / point1.distanceTo(point2);
            return gradient*100;
        }

        function getColorFromGradient(gradient) {
            var gradientScale = chroma.scale(['#8888ee', 'green', 'yellow', 'orange', 'red']).domain([-5, 0, 4, 6, 10]); // Example gradient scale
            return gradientScale(gradient).hex();
        }

        function displayElevation(segment) {
            // Logic for displaying elevation
            var points = segment.getLatLngs();
            for (var i = 0; i < points.length - 1; i++) {
                var elevation = points[i].meta.ele;
                var color = getColorFromElevation(elevation);
                L.polyline([points[i], points[i + 1]], { color: color }).addTo(map);
            }
        }
        function getColorFromElevation(elevation) {
            var elevationScale = chroma.scale(['#77ee77','green', 'yellow', 'orange', 'red']).domain([0, 100, 300, 600, 1000,1300]); // Example elevation scale
            return elevationScale(elevation).hex();
        }

    

        map.on('layeradd', function(event) {
            // Check if the added layer is a marker layer
            if (event.layer instanceof L.Marker) {
                // Remove the marker from the map
                map.removeLayer(event.layer);
            }
        });
    </script>
</body>
</html>
{% endblock %}